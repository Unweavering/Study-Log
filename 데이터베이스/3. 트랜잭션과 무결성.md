# 트랜잭션
- 데이터베이스에서 **논리적 작업 단위** (쿼리 묶음)
- ACID 원칙을 지켜야 함
## 원자성(Atomicity)
- 트랜잭션의 작업은 **모두 실행**되거나 **전혀 실행되지 않아야** 한다 **(all or nothing)**
- 커밋과 롤백덕에 데이터 무결성이 보장
### 커밋 (Commit)
- 트랜잭션 정상 종료 후 데이터 영구 반영 (롤백 불가 → 되돌리려면 새 트랜잭션으로 반대 작업 수행)
<img width="516" height="238" alt="image" src="https://github.com/user-attachments/assets/6b9ba054-fa3e-48ab-9c94-e90682a9c429" />

### 롤백 (Rollback) 
- 트랜잭션 실패 시 원상 복구 
<img width="510" height="293" alt="image" src="https://github.com/user-attachments/assets/2241b916-6408-443a-8cb6-ae7f59444690" />

### 트랜잭션 전파 (Transaction Propagation)
- A 트랜잭션 내에서 B 트랜잭션 호출 시 동작 방식
- 스프링에서는 `REQUIRED`, `REQUIRES_NEW` 같은 옵션으로 설정
- (추가)
## 일관성(Consistency)
- **정의**: 트랜잭션 전후로 데이터가 모든 무결성 제약조건을 만족.
- 예: 외래키 제약, 유니크 제약 등이 깨지면 트랜잭션 실패.
## 격리성(Isolation)
- **정의**: 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않도록 함
- 격리성이 높아지면 성능은 떨어진다 (trade off)
<img width="477" height="275" alt="image" src="https://github.com/user-attachments/assets/acc921f0-ecf8-4bf8-83b4-908c92c795ff" />

### 격리 수준에 따라 발생하는 현상
| 현상                                   | 설명              |
| ------------------------------------ | --------------- |
| **더티 리드 (Dirty Read)**               | 커밋되지 않은 데이터 읽음  |
| **반복 불가능한 조회 (Non-Repeatable Read)** | 같은 쿼리인데 값 바뀜    |
| **팬텀 리드 (Phantom Read)**             | 조건은 같은데 행 수가 바뀜 |

#### 팬텀 리드
- **한 트랜잭션 안에서 같은 조건으로 두 번 조회했는데, 두 번째 조회에서 “새로운 행(Row)”이 끼어드는 현상**
1. 트랜잭션 T1 시작 → 결과: 5명.
2. 동시에 다른 트랜잭션 T2가 새로운 고객(25살)을 INSERT하고 COMMIT.
3. 트랜잭션 T1이 다시 같은 쿼리 실행: → 결과: 6명.
- ⚡ 여기서 새로 나타난 그 1명이 **팬텀(유령)**
#### 반복 가능하지 않은 조회
- **같은 트랜잭션 안에서 같은 행(Row)을 두 번 읽었는데, 두 번째 읽을 때 값이 달라져 있는 현상**
1. 트랜잭션 T1 시작: → 결과: 100만 원.
2. 동시에 다른 트랜잭션 T2가 실행: → 50만원으로 UPDATE
3. 트랜잭션 T1이 같은 쿼리 다시 실행: → 결과: 50만 원
- ⚡ 똑같은 놈을 두 번 읽었는데 값이 바뀌었다. 이게 **Non-Repeatable Read**
#### 더티 리드
- **다른 트랜잭션이 아직 COMMIT하지 않은 데이터를 읽어버리는 상황**
- → 그 데이터는 롤백될 수도 있는데, 네 트랜잭션이 그걸 믿고 작전을 짜는 것
1. 트랜잭션 T1 시작: 0원으로 UPDATE (아직 COMMIT 안 함)
2. 트랜잭션 T2가 실행: → 결과: 0원 (Dirty Read 발생).
3. 그런데 T1이 롤백: 원래 잔액은 100만 원으로 되돌아감
- ⚡ 하지만 T2는 이미 “잔액 0원”이라고 믿고 결정을 내려버림 
### 격리 수준
| 수준                   | 방지되는 현상                     | 설명            |
| -------------------- | --------------------------- | ------------- |
| **READ UNCOMMITTED** | 없음                          | Dirty Read 허용 |
| **READ COMMITTED**   | Dirty Read                  | Oracle 기본     |
| **REPEATABLE READ**  | Dirty + Non-Repeatable Read | MySQL 기본      |
| **SERIALIZABLE**     | 모두 방지                       | 완전 격리, 성능 저하  |

#### SERIALIZABLE
- 트랜잭션들을 아예 “직렬 실행(Serial Execution)”처럼 동작시키는 격리 수준.
- 읽기(SELECT)조차 락을 건다
- 강력한 일관성을 보장하나, 성능도 떨어짐
#### REPEATEABLE_READ
- 트랜잭션 안에서 같은 행(Row)을 반복 조회하면 항상 같은 값이 보장되는 격리 수준.
  - 트랜잭션이 시작될 때, 스냅샷 생성
  - 같은 트랜잭션 안에서 재조회할 때, 이 “처음 본 스냅샷”을 기준으로 데이터를 보여준다.
  - 그래서 다른 트랜잭션이 UPDATE/COMMIT 해도 내 눈에는 안 바뀐 것처럼 보임.
- 새로운 행이 추가되는 것(팬텀리드)은 막지 못한다
#### READ_COMMITTED
#### READ_UNCOMMITTED
## 지속성(Durability)
- 트랜잭션이 커밋되면, 시스템 장애가 발생해도 결과는 보존되어야 한다.
- 디스크에 로그 등으로 기록 → 복구 가능
<img width="784" height="310" alt="image" src="https://github.com/user-attachments/assets/42b15136-80b5-4eeb-84e7-0f05dd087d86" />

# 무결성(Integrity)
- 데이터의 정확성·일관성·신뢰성을 유지하기 위한 제약조건
  
| 무결성 종류         | 설명                      |
| -------------- | ----------------------- |
| **개체 무결성**     | PK는 NULL, 중복 불가         |
| **참조 무결성**     | FK는 참조 대상 PK 존재 or NULL |
| **도메인 무결성**    | 필드값은 정의된 형식, 범위 따라야 함   |
| **사용자 정의 무결성** | 업무 규칙 기반 (예: 재고 ≥ 0)    |

<img width="623" height="265" alt="image" src="https://github.com/user-attachments/assets/4a84bf15-436d-4cc0-957a-1824a3c2ebf8" />

