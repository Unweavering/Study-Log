# ✅ 인덱스의 필요성
- 인덱스는 **데이터 검색 속도 향상**을 위해 사용된다.
- 책의 목차와 같다. 원하는 페이지를 빠르게 찾듯, 인덱스를 통해 DB는 전체 테이블을 스캔하지 않고 원하는 데이터를 효율적으로 찾을 수 있다.
- **없을 때**: Full Table Scan → `O(N)`
- **있을 때**: Index Lookup → `O(log N)`
<img width="388" height="240" alt="image" src="https://github.com/user-attachments/assets/ed0a927e-1c7d-4aa2-a329-b0f61ac7c56a" />

# ✅ B-트리
- 관계형 DB 대부분이 사용하는 기본 인덱스 구조.
- **균형 트리 구조**: 루트부터 리프까지의 깊이가 동일하게 유지된다.
- **검색, 삽입, 삭제 모두 O(log N)**
- **범위 검색에 강함**: `BETWEEN`, `ORDER BY`, `LIKE 'abc%'` 같은 연산이 효율적이다.
- 참고 : https://code-lab1.tistory.com/217
### ▶ 예시1
<img width="425" height="265" alt="image" src="https://github.com/user-attachments/assets/29e1a8b7-ec28-448b-9f05-2a66d139a78c" />

### ▶ 예시2
<img width="623" height="400" alt="image" src="https://github.com/user-attachments/assets/e49dd4c1-68c9-470f-a628-0be0070cbe2c" />


## ■ 인덱스가 효율적인 이유와 대수확장성
- **디스크 친화적**: 페이지 단위 읽기 → 캐시 효율적 (노드를 디스크 페이지 크기에 맞게 설계)
- **데이터 분산 저장**: 대량 데이터도 높이(log n)만큼 접근.
  - **대수확장성**: 데이터 n 건이 늘어도 검색 비용은 log n, 즉 10억 건이어도 높이는 수십 수준.
<img width="190" height="400" alt="image" src="https://github.com/user-attachments/assets/cc89d674-ccc3-44b4-87cb-5b7736a736bb" />

# ✅ 인덱스 만드는 방법
## ■ MySQL
```
-- 단일 컬럼 인덱스
CREATE INDEX idx_user_name ON users(name);

-- 복합 인덱스 (여러 컬럼 결합)
CREATE INDEX idx_user_name_age ON users(name, age);

-- 고유 인덱스
CREATE UNIQUE INDEX idx_user_email ON users(email);
```
## ■ MongoDB
```
// 단일 인덱스
db.users.createIndex({ name: 1 }) // 1: 오름차순, -1: 내림차순

// 복합 인덱스
db.users.createIndex({ name: 1, age: -1 })

// 고유 인덱스
db.users.createIndex({ email: 1 }, { unique: true })
```
# ✅ 인덱스 최적화 기법
## ■ 인덱스는 비용이다
- 읽기(Read) 비용
  - 인덱스 탐색 → 두 번 접근
  - (1) 인덱스(B-트리) 탐색
  - (2) 실제 데이터(테이블/클러스터 인덱스) 접근
- 쓰기(Write) 비용
  - INSERT: 인덱스 트리에도 새로운 키 삽입 → 정렬 유지 위해 리밸런싱 필요.
  - UPDATE: 인덱스 걸린 컬럼 변경 시 → 기존 인덱스 삭제 + 새 키 삽입.
  - DELETE: 인덱스에서 키 제거 후 트리 균형 재조정.
- 디스크 공간 소모.
- 따라서 “많이 쓰는 컬럼”만 선택적으로 걸어야 한다.
## ■ 항상 테스팅하라
- **실행 계획(EXPLAIN)** 확인 → 인덱스가 실제로 쓰이는지 확인해야 함.
- “만들면 쓰겠지”는 착각. DB는 필요 없으면 무시하고 풀스캔한다.
  - DBMS는 최적화기를 통해 실행 계획을 선택한다.
  - 인덱스가 있다고 항상 쓰는 게 아니라, 옵티마이저가 **Full Scan이 더 낫다**고 판단할 수도 있다.
  - `EXPLAIN`으로 실행 계획을 확인해야 한다
## ■ 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
- 복합 인덱스는 순서에 따라 성능이 달라진다
- **같음(Equal) → 정렬(Order) → 다중 값(Range) → 카디널리티(분포도)** 순서로 고려.
  - **같음 조건**: `=` 조건에 오는 컬럼은 앞으로.
  - **정렬 조건**: `ORDER BY`에 자주 쓰이는 컬럼은 앞쪽 배치.
  - **범위 조건**: `<`, `>`, `BETWEEN`은 뒤쪽 배치.
  - **카디널리티**: 값이 다양할수록(분포도가 클수록, 값들이 유니크할수록) 앞에 배치
    - ex) age보다 email이 카디널리티가 높다 (유니크한 값들이 많다)
