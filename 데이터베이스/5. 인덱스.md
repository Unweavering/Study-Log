# 인덱스의 필요성
- 인덱스는 **데이터 검색 속도 향상**을 위해 사용된다.
- 책의 목차와 같다. 원하는 페이지를 빠르게 찾듯, 인덱스를 통해 DB는 전체 테이블을 스캔하지 않고 원하는 데이터를 효율적으로 찾을 수 있다.
- **없을 때**: Full Table Scan → `O(N)`
- **있을 때**: Index Lookup → `O(log N)`
<img width="388" height="240" alt="image" src="https://github.com/user-attachments/assets/ed0a927e-1c7d-4aa2-a329-b0f61ac7c56a" />

# B-트리
- 관계형 DB 대부분이 사용하는 기본 인덱스 구조.
- **균형 트리 구조**: 루트부터 리프까지의 깊이가 동일하게 유지된다.
- **검색, 삽입, 삭제 모두 O(log N)**
- **범위 검색에 강함**: `BETWEEN`, `ORDER BY`, `LIKE 'abc%'` 같은 연산이 효율적이다.
- 참고 : https://code-lab1.tistory.com/217
### 예시1
<img width="425" height="265" alt="image" src="https://github.com/user-attachments/assets/29e1a8b7-ec28-448b-9f05-2a66d139a78c" />

### 예시2
<img width="623" height="400" alt="image" src="https://github.com/user-attachments/assets/e49dd4c1-68c9-470f-a628-0be0070cbe2c" />


## 인덱스가 효율적인 이유와 대수확장성
- **디스크 친화적**: 페이지 단위 읽기 → 캐시 효율적 (노드를 디스크 페이지 크기에 맞게 설계)
- **데이터 분산 저장**: 대량 데이터도 높이(log n)만큼 접근.
  - **대수확장성**: 데이터 n 건이 늘어도 검색 비용은 log n, 즉 10억 건이어도 높이는 수십 수준.
<img width="190" height="400" alt="image" src="https://github.com/user-attachments/assets/cc89d674-ccc3-44b4-87cb-5b7736a736bb" />

# 인덱스 만드는 방법
## MySQL
```
-- 단일 컬럼 인덱스
CREATE INDEX idx_user_name ON users(name);

-- 복합 인덱스 (여러 컬럼 결합)
CREATE INDEX idx_user_name_age ON users(name, age);

-- 고유 인덱스
CREATE UNIQUE INDEX idx_user_email ON users(email);
```
## MongoDB
```
// 단일 인덱스
db.users.createIndex({ name: 1 }) // 1: 오름차순, -1: 내림차순

// 복합 인덱스
db.users.createIndex({ name: 1, age: -1 })

// 고유 인덱스
db.users.createIndex({ email: 1 }, { unique: true })
```
# 인덱스 최적화 기법
## 인덱스는 비용이다
## 항상 테스팅하라
## 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
