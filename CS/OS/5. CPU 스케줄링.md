# ■ 프로그램 실행 시 CPU burst와 I/O burst
![image](https://github.com/user-attachments/assets/d76e9f1b-3133-4613-816b-1277084ff837)
```
- 주로 사람이 상호작용 하는 프로그램이 이렇게 CPU와 I/O 버스트가 번갈아 나온다
- 어떤 프로그램은 I/O작업 없이 CPU만 오래 쓰기도 한다
- 버스트의 빈도와 기간이 프로그램의 종류마다 다르다
```
  #### CPU Burst
  - 프로그램이 CPU 연산을 집중적으로 수행하는 기간
  - ex) load, store, add, read 등과 같은 연산
  #### I/O Burst
  - 프로그램이 입출력 작업을 수행하며, CPU는 이 기간 동안 대기(wait for I/O) 상태
  - ex) 파일 읽기/쓰기와 같은 작업
## CPU burst Time의 분포
![image](https://github.com/user-attachments/assets/ccd121ae-43d2-4f74-a759-2c8774fe070e)
- 프로세스들의 CPU 버스트 길이 별 빈도를 나타낸 그래프이다.
- heterogeneous한 그래프
- x축 : Burst duration (밀리초 단위, 작업의 지속 시간)
- y축 : Frequency (빈도)
  ### I/O Bound Job
  - 짧고 많은 CPU bursts
  - CPU보다 I/O작업에 시간을 많이 쓰는 job
  ### CPU Bound Job
  - 적고 긴 CPU bursts
  - 계산위주의 job
### 문제점
- CPU bound job이 CPU를 잡고 오랬동안 안놔주면 I/O bound job가 CPU를 못잡는다
- I/O bound job은 주로 사람과 상호작용 하는데, CPU를 못얻으면 사람이 답답해진다
- 그래서 CPU스케줄링이 필요하다

---

# ■ CPU Scheduler & Dispatcher
-
  ## CPU Scheduler
  - 어떤 프로세스에 CPU를 줄지 결정하는 코드
  ## Dispatcher
  - 결정했을때, 실제로 CPU를 넘겨주는 코드
## 종류
  ### preemptive (선점형)
  - 강제로 CPU 빼앗음
  ### nonpreemptive (비선점형)
  - CPU 자진반납. 강제x

 ---

# ■ 스케줄링 알고리즘
-
  ## 성능척도
  ### 1. 시스템 입장
  #### 이용률 (CPU utilization)
  - 전체 시간 중에서 CPU가 일한 시간
  - "최대한 바쁘게 일을 시켜라"
  #### 처리량 (Throughput)
  - 주어진 시간 동안에 몇개의 작업을 완료했느냐
  ### 2. 프로세스(고객) 입장
  - 프로세스 입장에선 CPU관련 시간이 중요하다
  #### 소요시간(Turnaround time)
  - CPU를 쓰려고 들어와서, 다 쓰고 나갈 때까지 걸린 시간
  #### 대기시간
