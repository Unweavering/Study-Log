# ■ 프로그램 실행 시 CPU burst와 I/O burst
![image](https://github.com/user-attachments/assets/d76e9f1b-3133-4613-816b-1277084ff837)
```
- 주로 사람이 상호작용 하는 프로그램이 이렇게 CPU와 I/O 버스트가 번갈아 나온다
- 어떤 프로그램은 I/O작업 없이 CPU만 오래 쓰기도 한다
- 버스트의 빈도와 기간이 프로그램의 종류마다 다르다
```
  #### CPU Burst
  - 프로그램이 CPU 연산을 집중적으로 수행하는 기간
  - ex) load, store, add, read 등과 같은 연산
  #### I/O Burst
  - 프로그램이 입출력 작업을 수행하며, CPU는 이 기간 동안 대기(wait for I/O) 상태
  - ex) 파일 읽기/쓰기와 같은 작업
## CPU burst Time의 분포
![image](https://github.com/user-attachments/assets/ccd121ae-43d2-4f74-a759-2c8774fe070e)
- 프로세스들의 CPU 버스트 길이 별 빈도를 나타낸 그래프이다.
- heterogeneous한 그래프
- x축 : Burst duration (밀리초 단위, 작업의 지속 시간)
- y축 : Frequency (빈도)
  ### I/O Bound Job
  - 짧고 많은 CPU bursts
  - CPU보다 I/O작업에 시간을 많이 쓰는 job
  ### CPU Bound Job
  - 적고 긴 CPU bursts
  - 계산위주의 job
### 문제점
- CPU bound job이 CPU를 잡고 오랬동안 안놔주면 I/O bound job가 CPU를 못잡는다
- I/O bound job은 주로 사람과 상호작용 하는데, CPU를 못얻으면 사람이 답답해진다
- 그래서 CPU스케줄링이 필요하다

---

# ■ CPU Scheduler & Dispatcher
-
  ## CPU Scheduler
  - 어떤 프로세스에 CPU를 줄지 결정하는 코드
  ## Dispatcher
  - 결정했을때, 실제로 CPU를 넘겨주는 코드
## 종류
  ### preemptive (선점형)
  - 강제로 CPU 빼앗음
  ### nonpreemptive (비선점형)
  - CPU 자진반납. 강제x

 ---

# ■ 스케줄링 알고리즘
-
  ## 성능척도
  ### 1. 시스템 입장
  -
    #### 이용률 (CPU utilization)
    - 전체 시간 중 CPU가 일한 시간
    - "최대한 바쁘게 일을 시켜라"
    #### 처리량 (Throughput)
    - 주어진 시간 동안에 완료한 작업의 수
  ### 2. 프로세스(고객) 입장
  - 프로세스 입장에선 CPU관련 시간이 중요하다
    #### 소요시간(Turnaround time)
    - 프로세스가 CPU를 쓰러 시스템에 들어와서, 다쓰고 나갈때까지 걸린 시간
    - 실행시간(burst) + 대기시간(waiting)
    #### 대기시간 (Waiting time)
    - CPU를 기다린 시간
    - CPU를 얻었다 뺏겼다 반복할 때, 그 사이사이의 대기 시간까지 포함
    #### 응답 시간 (Response time)
    - 처음으로 CPU를 얻기까지 걸린 시간
  ### 중국집 비유
  -
    #### 이용률 (CPU utilization)
    - 전체 시간 중, 주방장이 일한 시간 (쉬는 시간 제외)
    #### 처리량 (Throughput)
    - 주방장이 처리한 손님의 수
    #### 소요시간 (Turnaround time)
    - 손님이 중국집에 들어와서, 식사를 하고 나갈 때까지 소요된 시간
    #### 대기시간 (Waiting time)
    - 음식 기다린 시간
    - 코스요리라면, 음식을 먹고 다음 음식을 기다리는 시간까지 합쳐진다
    #### 응답 시간 (Response time)
    - 첫 번째 음식을 기다린 시간
 ## FCFS (First-Come First-Served)
- 먼저 온 순서대로 처리
- 인간사회에서 많이 쓰는 방식
#### 비선점형 스케줄링
- CPU 한번주면 빼앗지 않음
- 먼저 온 프로세스가 CPU 길게 쓰면 ***평균 대기 시간**이 길어져서 비효율적
  - 짧게 쓰는 프로세스가 앞에 배치되어야 **평균 대기 시간***이 짧아진다
#### Convoy effect
- CPU burtst time이 긴 프로세스가 짧은 프로세스 앞에 위치해서 평균 대기시간이 길어지는 상황
### 예시
![image](https://github.com/user-attachments/assets/ad5ac087-eef6-4d62-8c88-e9467a8165e5)
![image](https://github.com/user-attachments/assets/3f463add-f186-4f6b-b234-ce90d5f42958)
- 짧은 프로세스를 앞에 배치하니, 평균 대기 시간이 17에서 3이 되었다
## SJF (Shortest-Job_First)
- CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케줄
- **평균 대기 시간**이 가장 짧은 알고리즘
### 2가지 방식
- **Preemptive (선점형)** : 더 짧은 CPU burst time을 가진 프로세스가 오면, CPU를 빼앗김 ▶ SRTF (Shortest-Remaining-Time-First)
  - 문제점
    - Starvation(기아) 문제
      - CPU 사용시간이 긴 프로세스는 영원히 CPU를 못 받을 수도 있다 (계속 짧은애가 와서)
    - CPU 사용시간을 미리 알 수가 없는 문제
      - 어떤 프로세스가 CPU burst time 짧은건지 미리 알 수가 없는 문제 (입력 데이터, 분기(branch) 및 사용자 동작에 따라 달라짐)
      - (S) 추정 : 대신, 과거에 CPU를 얼마나 썻는지로 CPU 사용시간을 예측해서 적용
- **Nonpreemptive (비선점형)** :일단 CPU를 잡으면 burst가 끝날 때까지 뺏기지 않음
### 예시
![image](https://github.com/user-attachments/assets/4581b501-4cd1-4e02-9508-17146506dd44)
![image](https://github.com/user-attachments/assets/f4749b6e-e1bd-4623-805c-c9ec59ca6ead)
- 여기서 나온 3초가 optimal이다.
- 즉, 어떠한 알고리즘도 이 3초보다 낮은 값을 얻을 수 없다
### CPU burst time의 예측
- SJF 방식을 쓰려면 CPU burst time을 미리 알아야한다
- 하지만, 입력 데이터, 분기(branch) 및 사용자 동작에 따라 burst time이 달라져서 미리 알기 어렵다.
- 따라서, 과거 데이터를 활용해 예측한다.
- 과거의 CPU Burst Time을 기반으로 지수적 평균(Exponential Averaging)을 사용하여 추정
![image](https://github.com/user-attachments/assets/bdf0641a-9b9b-43af-91ff-f3e7e79a3eb4)
![image](https://github.com/user-attachments/assets/4e25a830-dbe4-4b70-a6cc-cedf6e22e93f)
- 수식을 전개해보면, 오래된 데이터일 수록 영향력이 줄어드는 구조로 되어있다. (참고 : https://43434.tistory.com/160#SJF%20(Shortest-Job_First)-1)
## Priority Scheduling
- 우선순위가 가장 높은 프로세스에게 CPU를 준다
