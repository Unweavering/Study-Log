# ■ 데이터의 접근
![Image](https://github.com/user-attachments/assets/bd76ab4a-e77e-4fc3-8639-afccaa834244)
- 컴퓨터 시스템에서 data에 접근하는 공통적 패턴을 추상화한 그림
- data를 읽기만 하면 문제없지만, 수정하고 저장하면서 동기화 문제가 생긴다
- **동기화 문제** : data를 동시에 읽고 수정해서 저장하면, 한쪽의 연산만 반영된다
## Race Condition
![Image](https://github.com/user-attachments/assets/8f6cfa45-c104-4b58-88f7-e10f7be62a98)
![Image](https://github.com/user-attachments/assets/461f29f5-a172-4787-832c-4a134a3df818)
- Race Condition : 여러 주체가 하나의 자원에 동시에 접근하려고 함
- 마지막에 그 data를 다룬 주체가 누구냐에 따라 연산 결과가 달라짐
  ### OS에서 Race Condtion은 언제 발생하는가?
  1. Kernel 수행 중 인터럽트 발생 시
  2. Process가 system call을 하여 kernel mode로 수행 중인데, context switch가 일어나는 경우
  3. Multiprocessor에서 shared memory내의 kernel data
  
  참고 : https://43434.tistory.com/161
## 정리
- **공유 데이터**(shared data)의 **동시 접근**(concurrent access)은 데이터의 **불일치문제**(inconsistency)를 야기할 수 있다
- **일관성**(consistency) 유지를 위해서는, **협력 프로세스간**(cooperating process)의 **실행 순서**(orderly execution)를 정해주는 매커니즘이 필요하다
- **Race Condition**을 막기 위해서 **concurrent process**는 **동기화**(synchronize)되어야 한다

---

# ■ The Critical-Section Problem
#### Critical Section
- 공유 데이터에 접근하는 코드
#### Problem
- 하나의 프로세스가 Critical Section에 있으면 다른 프로세스는 Critical Section에 들어가지 못하게 해야한다
