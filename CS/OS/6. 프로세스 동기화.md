# ■ 데이터의 접근
![Image](https://github.com/user-attachments/assets/bd76ab4a-e77e-4fc3-8639-afccaa834244)
- 컴퓨터 시스템에서 data에 접근하는 공통적 패턴을 추상화한 그림
- data를 읽기만 하면 문제없지만, 수정하고 저장하면서 동기화 문제가 생긴다
- **동기화 문제** : data를 동시에 읽고 수정해서 저장하면, 한쪽의 연산만 반영된다
## Race Condition
![Image](https://github.com/user-attachments/assets/8f6cfa45-c104-4b58-88f7-e10f7be62a98)
![Image](https://github.com/user-attachments/assets/461f29f5-a172-4787-832c-4a134a3df818)
- Race Condition : 여러 주체가 하나의 자원에 동시에 접근하려고 함
- 마지막에 그 data를 다룬 주체가 누구냐에 따라 연산 결과가 달라짐
  ### OS에서 Race Condtion은 언제 발생하는가?
  1. Kernel 수행 중 인터럽트 발생 시
  2. Process가 system call을 하여 kernel mode로 수행 중인데, context switch가 일어나는 경우
  3. Multiprocessor에서 shared memory내의 kernel data
  
  참고 : https://43434.tistory.com/161
## 정리
- **공유 데이터**(shared data)의 **동시 접근**(concurrent access)은 데이터의 **불일치문제**(inconsistency)를 야기할 수 있다
- **일관성**(consistency) 유지를 위해서는, **협력 프로세스간**(cooperating process)의 **실행 순서**(orderly execution)를 정해주는 매커니즘이 필요하다
- **Race Condition**을 막기 위해서 **concurrent process**는 **동기화**(synchronize)되어야 한다

---

# ■ The Critical-Section Problem
#### Critical Section
- 공유 데이터에 접근하는 코드
#### Problem
- 하나의 프로세스가 Critical Section에 있으면 다른 프로세스는 Critical Section에 들어가지 못하게 해야한다
## 프로그램적 해결법
### 프로그램적 해결법의 충족조건
- Mutual Exclusion : 하나가 들어가 있으면 다른건 못 들어감
- Progress : 비어있으면 들어가게 해줌
- Bounded Waiting : 유한 대기 (starvation 방지)
#### 알고리즘1
- turn 사용
- 자기 turn일때만 입장. 아닐때는 대기 
- **단점** : spin lock, mutual exclusion은 만족하나, progress는 만족하지 않는다. ▶ 비어있어도, 반드시 상대가 Critical section에 들어갔다 나와야 나한테 turn이 돌아옴
#### 알고리즘2
- flag 사용
- 내가 사용하겠다는 flag를 든 뒤, 상대의 flag를 확인해서 안들고 있으면 진입하고, 상대가 들고있으면 상대가 내릴때까지 대기한다
- **단점** : spin lock, flag를 든 상태로 CPU가 뺏기면 서로 flag를 들고있는 교착상태 발생 가능
#### 알고리즘3 (피터슨 알고리즘)
- turn, flag 둘 다 사용
- 상대가 flag를 들고 turn을 가졌으면 대기한다. 하나라도 만족하지 않으면 진입한다.
- **단점** : spin lock (busy waiting) ▶ CPU 낭비
## 하드웨어적 해결법
- Critical-Section문제는, 읽고 쓰는 중간에 CPU를 빼앗겨서 생긴다.
- 읽고 쓰는 것이 여러개의 instruction으로 구성되어서 중간에 CPU를 빼앗길 수 있는 것이다
- 그러니 읽고 쓰는 것이 하나의 instruction으로 한번에 수행되면 해결된다 (atomic한 수행)
- 그러한 instruction을 하드웨어가 제공하는게 하드웨어적 해결법
### ex) test_and_set
![Image](https://github.com/user-attachments/assets/ca95af2b-e2b1-475b-b5e7-c5e6c585f6e5)
- Test_and_set(a)
  - 동작 : 변수 a의 값을 반환하는 동시에, 값을 True로 교체한다. 
- while문 안에서, lock이 false면 critical section에 진입하는 동시에 true로 바꿔서 잠궈버린다
- while문 안에서, lock이 true면 계속 true상태로 무한루프를 돈다

---

# ■ Semaphores
- 위에서 설명한 방식들을 추상화한 자료형
- Semaphores S라고 선언하면, 변수 S에는 공유자원의 갯수를 저장한다 (inteager)
### 연산
- P(S) : 공유자원 획득 (S의 값 감소) ▶ 자원이 없을땐 **busy waiting**
- V(S) : 공유자원 반납 (S의 값 증가)
- P연산과 V연산은 atomic하게 수행된다
### 예시
![Image](https://github.com/user-attachments/assets/2c2b6d07-928d-47f5-8bbb-0035952406e7)
-  진입할때 P연산 나올때 V연산
## Block & Wakeup Implementation
- busy-wait을 해결하기 위한 방법
