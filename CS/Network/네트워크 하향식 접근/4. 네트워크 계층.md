![image](https://github.com/user-attachments/assets/6c98205d-a9a4-419c-8615-ef7fc42c0d32)

### 프로토콜
- app 계층 : HTTP
- trans 계층 : TCP, UDP
- Network 계층 : IP

<br>

### 라우터가 하는 일
1. 포워딩
2. 라우팅

---

# 라우터가 하는 일
  ### 포워딩
  - 패킷을 보내는 것
  - 패킷 해더에서 목적지를 읽음
  - **포워딩 테이블**에서 그 목적지를 찾고 패킷을 보냄
  ### 라우팅
  - 패킷의 경로를 설정하는 것
  - 포워딩 테이블을 만듬
  - 라우팅 알고리즘을 사용
  
---

# IP주소 (IPv4)
- 32비트
- 8비트씩 끊어서 4개로 분할
- 인터페이스를 식별하는데 사용
### 인터페이스
- 호스트or 라우터 안에 있는 네트워크 인터페이스 (NIC)
- LAN카드, WIFI 어댑터 등...
- 한 컴퓨터에 인터페이스 n개 꼽으면 ip도 n개 할당 됨. 라우터가 그런식임

---

# 호스트 그룹화
## LAN
- Local Area Network
- 동일한 지역내 네트워크
- 학교, 회사, 가정 내 네트워크
- ex) LAN1 = 한양대 네트워크, LAN2 = 숭실대 네트워크
## WAN
- Wide Area Network
- LAN같은 지역 네트워크들을 서로 연결하는 더 큰 범위의 네트워크
## 인터넷
- Inter + Network
- 개별 호스트가 아니라 네트워크 자체를 연결함
- LAN과 WAN이 모여서 형성된 전 세계적인 네트워크

---

# 계층적 주소 지정
## 확장성 문제
- ${\textsf{\color{red}(P)}}$ 호스트들이 랜덤 주소를 가진다면, 라우터는 모든 호스트의 주소를 알아야하고, 포워딩 테이블의 크기가 너무 커진다
- ${\textsf{\color{blue}(S)}}$ 계층적 구조를 사용하여, 네트워크의 일부 정보만으로 포워딩할 수 있게 설계
## IP Prefixes (계층적 주소 지정 방법)
- IP주소의 앞부분(Prefix)는 네트워크 ID
- IP주소의 뒷부분은 호스트 IP
- 같은 네트워크에 속한 호스트들은 Prefix부분이 같음
- ${\textsf{\color{Emerald}ex)}}$ 12.34.158/24
  - 24비트까지 Prefix라는 뜻
- 장점
  - 확장성 문제 개선
  - 호스트 추가의 용이함 : 포워딩 테이블을 추가할 필요가 없음 (라우터를 업데이트할 필요가 없음)
## 서브넷 마스크 (Subnet Mask)
- IP주소에 서브넷 마스크를 따라다니게 해서, 어디까지가 Prefix인지 구분하게 한다.
- (패킷에는 없다. 패킷은 가벼워야 되서)
## 계층적 주소 할당
- 대규모 네트워크 블록(예: 12.0.0.0/8)이 할당되고, 그 안에서 더 작은 서브넷 블록(예: 12.1.0.0/16, 12.2.0.0/16 등)이 할당됩니다. 이와 같이, 서브넷 블록들은 점점 더 작은 프리픽스로 나뉘어, 특정 네트워크 범위를 정의합니다

---

# Classful Addressing VS CIDR
## Classful Addressing
- 과거에 사용되던, **고정된 크기**의 주소 할당 방식
- 네트워크의 크기에 따라, 클래스를 결정
- IP주소의 첫 몇비트에 의해 클래스가 결정된다
  - Class A: 0으로 시작, 매우 큰 네트워크에 할당됨 (/8 블록, 예: MIT의 18.0.0.0/8)
  - Class B: 10으로 시작, 큰 네트워크에 할당됨 (/16 블록, 예: Princeton의 128.112.0.0/16)
  - Class C: 110으로 시작, 작은 네트워크에 할당됨 (/24 블록, 예: AT&T Labs의 192.20.225.0/24)
  - Class D: 1110으로 시작, 멀티캐스트 그룹을 위한 예약
  - Class E: 11110으로 시작, 미래 사용을 위해 예약됨
## Classless inter-Domain Routing (CIDR)
- 클래스가 없고, **서브넷 마스크**로 네트워크id의 범위를 정한다
- 장점
  - 유연성
  - 효율성 : 필요한 만큼의 IP주소만 할당해서 주소 낭비 줄임
### (P) CIDR 패킷 포워딩의 문제점
- 포워딩 테이블에 여러 일치 항목이 발생할 수 있다
### (S) Longest Prefix Match Forwarding
- 가장 길게 매칭되는 prefix를 기준으로 포워딩한다.

---

# 서브넷 (Subnet)
- 같은 서브넷id(prefix)를 가진 디바이스 인터페이스의 집합
- 라우터를 거치지 않고 접근이 가능한 host들의 집합

---

# ICMP (Internet Control Message Protocol)
- 네트워크 상에서 이런저런 증상들을 알기위한 컨트롤 메세지를 보내는 프로토콜
- 네트워크 계층에서 동작, IP 데이터그램에 존재
- 구성
  - 타입
  - 코드
  - 오류를 발생시킨 IP데이터그램의 처음 8바이트
## Traceroute
- 네트워크 경로를 추적
- 각 라우터의 ICMP메세지를 통해 각 구간의 응답시간을 측정
  - 예시) TTL = 1은 첫번째 라우터에서 소멸되어 ICMP로 왕복시간(RTT), TTL=2는 두번째 라우터 왕복시간 알려줌

 ---

 # IPv6
 - 만들어진지 한참됐는데 안쓰는걸로 보아, 사용될 확률 낮으니 대충 알아두자
 - address 비트를 128비트로 해서 주소 갯수가 넋넋하다
## Tunneling
- IPv6와 IPv4가 공존하는 과도기엔 터널링이 필요함
- IPv6패킷을 IPv4패킷 안에 캡슐화하여 IPv4를 통과하고, IPv6에서 다시 복원함

---

# 라우팅
## 그래프 추상화
- 라우터를 노드, 라우터간의 연결을 엣지로 본다
- 링크 코스트 : 물리적거리, 트래픽 등
## 라우팅 알고리즘 분류
### 글로벌
- Link State 알고리즘
- 모든 링크 cost를 알고있을 때
### 분산
- Distance Vector 알고리즘
- 이웃 라우터의 정보만 앎, 링크 코스트는 이웃과의 교환 과정에서 얻음
## Link State 알고리즘
- 다익스트라 알고리즘
- 진동 : 링크코스트가 바뀌는 경우 추가적인 조정
## Distance Vector 알고리즘
- 거리 벡터(행렬)을 갱신하고 이웃에게 알려주는 알고리즘
- 벨만포드 방정식 사용 (동적 프로그래밍)
- 벨만포드 방정식으로 거리벡터를 관리하면서, 최소거리가 업데이트 될 때마다 이웃에게 알림
### Count to infinity 문제
- (P) 이웃의 최소거리가 자신을 거쳐갈 때, 최소거리가 조금씩 업데이트 되는 문제
- (S) 최소거리가 이웃을 거쳐갈때, 그 이웃에게 그걸 전달하지 않거나, 무한대로 전달한다

---

# AS (Autonomous System)
### 계층화
- (P) 네트워크가 너무 커서 연결이 복잡하다
- (S) 네트워크를 계층화한다
- Inter-AS와 intra-AS로 계층화
- ex) 한양대에서 구글로 연결
  - intra-AS 라우팅 알고리즘으로 한양대 내부에서 한양대 게이트웨이로 연결
  - inter-AS 라우팅 알고리즘으로 한양대 게이트웨이에서 구글 게이트웨이로 연결
 ### ASN
 - AS는 AS Number를 부여받는다.
 - ASN은 6만개 넘는다
## AS간의 관계
- ISP를 운영하는데는 돈이든다.
- 그래서 고객으로부터 돈을 받는다.
- 작은 네트워크는 더 큰 네트워크의 고객이다. (Tier)
### Provier customer 관계
- provider은 ISP를 제공하고, customer은 돈을 낸다.
- ex)
  - 한양대 ㅡ> 학생
  - SKT ㅡ> 한양대
### Peering 관계
- provider끼리 각자의 고객을 위해 트래픽을 주고 받는다.
- 각각의 고객에게 돈을 받으면 되기 때문이다.
- 이걸 provider의 peering 관계라고 한다.
- 고객없이 provider끼리 트래픽을 주고받지 않는다. 금전적 이득이 없기 때문
## BGP
