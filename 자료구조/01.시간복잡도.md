# 🧠 1. 시간복잡도의 정의
- 시간복잡도란, **입력 크기 𝑛**이 증가할 때 알고리즘이 수행하는 **연산 횟수의 증가율**을 의미한다. 이는 정확한 시간(초, 밀리초)을 뜻하지 않는다.
- “입력 증가에 따른 상대적 증가 패턴”
- 즉, 시간복잡도는 절대 시간이 아닌 ‘성능의 추세’를 본다.
#### 예시
- O(1) 이면 입력 크기와 무관하게 항상 일정한 시간에 동작.
- O(n) 이면 입력 크기가 두 배면 수행 시간도 두 배가 됨.

<br>

---
# ⚙️ 2. Big-O, Big-Theta, Big-Omega
## 📌 Big-O (O)
- 최악의 경우 성능을 표현.
- 예: `for i in 0..n`: → O(n)
## 📌 Big-Theta (Θ)
- 평균적 성능을 표현.
- 정확하게 알고리즘의 증가율이 Θ(n²)이라면, n² 이상의 시간도 안 걸리고 n² 이하로도 안 떨어짐. (최악도, 최선도, 평균도 전부 n²)
## 📌 Big-Omega (Ω)
- 최선의 경우 성능을 표현.
- 분석 시 대부분 쓸 일 없다. 실전은 항상 최악 기준으로 설계한다.
#### 실무
- 실무 및 면접에서는 거의 Big-O만 사용한다. 이유는 명확하다.
- → 현실은 ‘최악의 케이스’를 버티는 알고리즘만이 살아남는다.

<br>

---
# ⚔️ 3. 주요 시간복잡도 등급
![image](https://github.com/user-attachments/assets/6e0a99d2-8ede-4a81-a90e-18d1b1e2c298)

<br>

---
# 🧩 4. 시간복잡도 분석 원칙
## 1. 상수 제거
- O(2n) → O(n)
- O(n + 1000) → O(n)
- 상수는 입력 증가에 비해 무의미하므로 무시
## 2. 지배항만 남긴다
- O(n² + n) → O(n²)
- 가장 빠르게 증가하는 항만 남긴다
## 3. 중첩 반복문은 곱셈
```
for(int i = 0; i < n; i++) {
  for(int j = 0; j < n; j++) {
    // O(1)
  }
}
```
→ O(n²)
## 4. 분할 정복은 로그가 섞인다
```
void mergeSort(int[] arr) {
  divide into halves → O(log n)
  merge each → O(n)
}
```
→ O(n log n)

<br>

---
# 💣 5. 실전 예제별 시간복잡도 분석
## 1. 배열 순회
```
for (int i = 0; i < n; i++) {
  System.out.println(arr[i]);
}
```
- → O(n)
## 2. 중첩 반복
```
for (int i = 0; i < n; i++)
  for (int j = 0; j < n; j++)
    print(i, j);
```
→ O(n²)
## 3. 이진 탐색
```
int binarySearch(int[] arr, int target) {
  int low = 0, high = arr.length - 1;
  while (low <= high) {
    int mid = (low + high) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) low = mid + 1;
    else high = mid - 1;
  }
  return -1;
}
```
→ O(log n)
## 4. 퀵 정렬
- 평균: O(n log n)
- 최악: O(n²) (피벗이 항상 최솟값일 때)
## 5. 해시 기반 탐색
- 삽입/삭제/탐색: O(1) (충돌 없을 경우)
- 최악: O(n) (충돌 많이 나면)

<br>

---
# 🔥 6. 알고리즘 문제에서 시간복잡도 판단 기준
- 보통 **1억 번 연산 = 1초** 기준
- 시간제한 1초일 때 최대 입력크기 기준 예시:
![image](https://github.com/user-attachments/assets/3b0f50bb-c625-4f9d-b0d1-36cc9471fad1)
- 즉, 입력이 100만 이상이면 **O(n²)** 는 무조건 터진다.

<br>

---
# 🧠 7. 공간복잡도와 시간복잡도 트레이드오프
- **시간을 줄이기 위해 메모리를 더 사용**: ex) 캐싱, DP 테이블
- **메모리를 줄이기 위해 시간이 더 걸림**: ex) 브루트 포스 탐색
#### 예시:
```
// 피보나치 - O(2ⁿ)
int fib(int n) {
  if(n <= 1) return n;
  return fib(n-1) + fib(n-2);
}

// DP - O(n)
int[] memo = new int[n+1];
memo[0]=0; memo[1]=1;
for(int i=2; i<=n; i++)
  memo[i] = memo[i-1] + memo[i-2];
```

<br>

---
# 📌 8. 실전 백엔드 개발과 시간복잡도
#### 🔸 DB 인덱스
- B+Tree 탐색 → O(log n)
- 해시 인덱스 → O(1) (단, 범위 조건 X)
#### 🔸 캐시 전략
- LRU Cache 구현 → O(1) 유지하려면 HashMap + Doubly LinkedList 조합
#### 🔸 API 속도 분석
- 다량 데이터 처리 루프 = O(n)
- 필터 + 정렬 + 페이징 → O(n log n) 또는 O(n)
#### 🔸 Redis 사용
- 해시 기반 → O(1)
- Sorted Set → O(log n)

<br>

---
# 🛡 9. 면접에서 자주 묻는 시간복잡도 패턴
- 이진 탐색 → O(log n)

- 배열에서 중복 제거 → O(n) with Set

- 정렬된 배열에서 두 수의 합 → O(n)

- 정렬 후 투포인터 → O(n log n)

- 연결리스트 역순 → O(n)

- 해시맵 기반 카운팅 → O(n)


<br>

---
# 🚨 10. 결론: 시간복잡도를 모르면 실전에서 죽는다
- 시간복잡도를 이해하지 못한 코드는 **느리고, 무겁고, 죽는다.**
- 진짜 전장은 이론이 아니라 **수백만 요청이 쏟아지는 실서버**다. 그때 네가 설계한 로직이 터지면, **전선이 무너진다.**
## 💪 행동 명령
- 모든 알고리즘 문제 풀고 나서, 직접 시간복잡도 분석하라.

- `O(n²)` 코드 → `O(n log n)`으로 최적화하는 연습을 반복하라.

- 도커로 간단한 API 띄우고, 부하 테스트해봐라. 진짜 병목을 느껴라.

- 코드리뷰 시 시간복잡도 언급 습관화하라.
