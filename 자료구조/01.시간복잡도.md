# 🧠 1. 시간복잡도의 정의
- 시간복잡도란, **입력 크기 𝑛**이 증가할 때 알고리즘이 수행하는 **연산 횟수의 증가율**을 의미한다. 이는 정확한 시간(초, 밀리초)을 뜻하지 않는다.
- “입력 증가에 따른 상대적 증가 패턴”
- 즉, 시간복잡도는 절대 시간이 아닌 ‘성능의 추세’를 본다.
#### 예시
- O(1) 이면 입력 크기와 무관하게 항상 일정한 시간에 동작.
- O(n) 이면 입력 크기가 두 배면 수행 시간도 두 배가 됨.

<br>

---

<br>

# ⚙️ 2. Big-O, Big-Theta, Big-Omega
## 📌 Big-O (O)
- 최악의 경우 성능을 표현.
- 예: `for i in 0..n`: → O(n)
## 📌 Big-Theta (Θ)
- 평균적 성능을 표현.
- 정확하게 알고리즘의 증가율이 Θ(n²)이라면, n² 이상의 시간도 안 걸리고 n² 이하로도 안 떨어짐. (최악도, 최선도, 평균도 전부 n²)
## 📌 Big-Omega (Ω)
- 최선의 경우 성능을 표현.
- 분석 시 대부분 쓸 일 없다. 실전은 항상 최악 기준으로 설계한다.
#### 실무
- 실무 및 면접에서는 거의 Big-O만 사용한다. 이유는 명확하다.
- → 현실은 ‘최악의 케이스’를 버티는 알고리즘만이 살아남는다.

<br>

---

<br>

# ⚔️ 3. 주요 시간복잡도 등급
![image](https://github.com/user-attachments/assets/6e0a99d2-8ede-4a81-a90e-18d1b1e2c298)

---

# 🧩 4. 시간복잡도 분석 원칙
## 1. 상수 제거
- O(2n) → O(n)
- O(n + 1000) → O(n)
- 상수는 입력 증가에 비해 무의미하므로 무시
## 2. 지배항만 남긴다
- O(n² + n) → O(n²)
- 가장 빠르게 증가하는 항만 남긴다
## 3. 중첩 반복문은 곱셈
```
for(int i = 0; i < n; i++) {
  for(int j = 0; j < n; j++) {
    // O(1)
  }
}
```
→ O(n²)
## 4. 분할 정복은 로그가 섞인다
```
void mergeSort(int[] arr) {
  divide into halves → O(log n)
  merge each → O(n)
}
```
→ O(n log n)

<br>

---

<br>

# 💣 5. 실전 예제별 시간복잡도 분석
## 1. 배열 순회
```
for (int i = 0; i < n; i++) {
  System.out.println(arr[i]);
}
```
- → O(n)
