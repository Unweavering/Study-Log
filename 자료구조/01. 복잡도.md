# 시간 복잡도 (Time Complexity)
> 입력 크기당 연산 증가율
- 정확한 시간이 아니라, 입력크기에 따른 상대적 증가 패턴
- 현실에서 코드 실행 시간은 환경(하드웨어, 캐시, 언어 구현)에 따라 달라지기 때문
- 코드의 효율성 척도
## 빅오 표기법
> 최악의 경우 실행 시간
- 빅오 표기법은 **상한선(Upper Bound)** 을 의미한다.
- 즉, “최악의 경우에도 이 정도 이하로 동작한다”는 보장.
- 미미한 영향을 끼치는 것 제거
  - **상수 제거**: O(2n) → O(n)
  - **하위항 제거**: O(n² + n + 1) → O(n²)
  - 이유: 입력이 커질수록 지배항이 모든 걸 지배한다.
- 예시:
  - O(1): 입력 크기와 상관없이 즉시 → 해시 테이블 검색
  - O(log N): 반씩 줄여가며 탐색 → 이진 탐색
  - O(N): 입력 크기만큼 → 단순 순회
  - O(N log N): 효율적 정렬 (퀵/머지/힙)
  - O(N²): 중첩 루프 → 버블/삽입/선택 정렬
  - O(2^N): 조합 폭발 → 부분집합 탐색
  - O(N!): 순열 전부 탐색 → 외판원 문제 완전탐색
## 시간 복잡도의 속도 비교
<img width="333" height="242" alt="image" src="https://github.com/user-attachments/assets/5b2a745e-7b70-4e5a-9cc0-4627364f2e0d" />

# 공간 복잡도
> 입력 크기당 메모리 증가율
# 자료 구조에서의 시간 복잡도
## 평균 시간 복잡도
| 자료 구조             | 접근   | 탐색   | 삽입     | 삭제     |
|-----------------------|--------|--------|----------|----------|
| 배열 (array)          | O(1)   | O(n)   | O(n)     | O(n)     |
| 스택 (stack)          | O(n)   | O(n)   | O(1)     | O(1)     |
| 큐 (queue)            | O(n)   | O(n)   | O(1)     | O(1)     |
| 이중 연결 리스트      | O(n)   | O(n)   | O(1)     | O(1)     |
| 해시 테이블 (hash)    | O(1)   | O(1)   | O(1)     | O(1)     |
| 이진 탐색 트리 (BST)  | O(logn)| O(logn)| O(logn)  | O(logn)  |
| AVL 트리              | O(logn)| O(logn)| O(logn)  | O(logn)  |
| 레드 블랙 트리        | O(logn)| O(logn)| O(logn)  | O(logn)  |
## 최악 시간 복잡도
| 자료 구조             | 접근   | 탐색   | 삽입     | 삭제     |
|-----------------------|--------|--------|----------|----------|
| 배열 (array)          | O(1)   | O(n)   | O(n)     | O(n)     |
| 스택 (stack)          | O(n)   | O(n)   | O(1)     | O(1)     |
| 큐 (queue)            | O(n)   | O(n)   | O(1)     | O(1)     |
| 이중 연결 리스트      | O(n)   | O(n)   | O(1)     | O(1)     |
| 해시 테이블 (hash)    | O(n)   | O(n)   | O(n)     | O(n)     |
| 이진 탐색 트리 (BST)  | O(n)   | O(n)   | O(n)     | O(n)     |
