# ✅ 1. CPU란 무엇인가?
- **CPU (Central Processing Unit)**는 컴퓨터의 "두뇌"다.
- 명령어를 받아서 해석하고 실행한다.
- 네 코드의 `if`, `for`, `+`, `-` 이런 모든 연산이 결국 CPU에서 돌아간다.

<br>

---
# ✅ 2. CPU의 구조
## 🔹 1) 주요 구성 요소
| 구성 요소              | 설명                                  |
| ------------------ | ----------------------------------- |
| **ALU (산술논리연산장치)** | +, -, AND, OR 같은 계산 처리              |
| **CU (제어장치)**      | 명령어를 해석하고 ALU, 레지스터, 메모리 제어         |
| **레지스터**           | 초고속 임시 기억 장치 (몇 비트 수준)              |
| **캐시 메모리**         | RAM보다 빠른 저장소. L1, L2, L3로 나뉨        |
| **버스 (Bus)**       | 데이터, 주소, 제어 신호를 CPU ↔ 메모리 ↔ I/O로 전달 |
## 🔹 2) CPU 내부 동작 흐름
1. **명령어 인출(Fetch)** - 메모리에서 명령어 읽어옴
2. **해독(Decode)**- 무슨 명령인지 파악
3. **실행(Execute**) - ALU를 통해 연산 수행
4. **메모리 접근(Memory Access)** - 결과 저장하거나 불러오기
5. **쓰기(Write back)** - 결과를 레지스터나 메모리에 저장

<br>

---
# ✅ 3. 클럭, 사이클, IPC
## 🔹 클럭 주파수 (Clock Rate)
- CPU가 **1초에 몇 번 명령을 처리할 수 있나?**
- 단위: GHz (1GHz = 10⁹ Hz = 10억 싸이클/초)
## 🔹 클럭 사이클 (Clock Cycle)
- CPU 내부에서 한 동작을 수행하는 데 필요한 최소 시간 단위
- 예: 한 명령어가 3사이클이면, 3번 클럭이 돌아야 실행됨
## 🔹 IPC (Instructions Per Cycle)
- 1클럭당 평균 실행되는 명령어 수
- 성능 = 클럭 주파수 × IPC
- 👉 CPU가 빠르려면? **높은 클럭 + 높은 IPC 둘 다 필요.**

<br>

---
# ✅ 4. 멀티코어와 병렬 처리
## 🔹 멀티코어란?
- CPU 안에 여러 개의 실행 유닛 (코어)이 있는 구조
- 하나의 물리적 CPU가 여러 작업을 동시에 처리 가능

| 용어              | 설명                    |
| --------------- | --------------------- |
| **코어(Core)**    | 독립 실행 유닛              |
| **쓰레드(Thread)** | CPU가 처리할 작업 흐름 단위     |
| **하이퍼스레딩**      | 1코어가 2개 쓰레드 실행 (논리코어) |
| **멀티코어**        | 진짜 코어가 여러 개 있음        |
>즉, 4코어 8쓰레드 CPU는 물리적으로 4개, 논리적으로 8개.

<br>

---
# ✅ 5. 문맥 교환 (Context Switching)
- 멀티태스킹 OS에서는 CPU가 작업을 빠르게 전환하며 여러 작업을 "동시에" 처리한다.
- 이때 CPU는 현재 작업의 상태를 저장하고, 다음 작업의 상태를 불러온다. 이것이 **문맥 교환(Context Switch)**이다.

## 🔹 전환 비용
- 캐시 무효화
- 레지스터 저장/복원
- 커널 ↔ 유저 모드 전환
- 문맥 전환은 비싼 작업이다. 많아질수록 성능 저하.

<br>

---
# ✅ 6. 캐시 메모리 (Cache)
## 🔹 계층 구조
- L1: 코어 내부, 가장 작고 가장 빠름 (~32KB)
- L2: 코어 내부 or 공유 (~256KB)
- L3: 여러 코어 공유 (~16MB)
> CPU는 RAM보다 수백 배 빠르다. 그래서 RAM에서 직접 접근하지 않고 캐시를 사용한다.
## 🔹 캐시 미스
- Cache Hit: 원하는 데이터가 캐시에 있음
- Cache Miss: 없음 → RAM 접근 → 성능 저하
> 성능 향상 핵심 = 캐시 활용 극대화

<br>

---
# ✅ 7. 파이프라이닝 (Pipelining)
- CPU 내부 작업을 나눠서 **동시에 실행**하는 구조
| 단계  | 예시     |
| --- | ------ |
| IF  | 명령어 인출 |
| ID  | 명령어 해독 |
| EX  | 실행     |
| MEM | 메모리 접근 |
| WB  | 결과 저장  |
> 동시에 여러 명령을 "쪼개서" 실행. 마치 공장처럼.
## 🔹 문제점: Hazard
- **Data Hazard**: 앞 명령어 결과를 뒤가 기다림
- **Control Hazard**: 분기문으로 인한 불확실성 (if, for)
- **Structural Hazard**: 자원 부족

<br>

---
# ✅ 8. 인터럽트 (Interrupt)
- CPU는 평소에는 코드만 실행한다.
- 그런데 외부 장치나 예외 상황이 발생하면 중간에 끼어드는 신호가 있다.
- 이게 **인터럽트**다.
## 🔹 예시
- 마우스 클릭
- 키보드 입력
- I/O 완료
- 0으로 나누기 등 오류
- 👉 **CPU는 인터럽트를 받고, 커널모드로 진입하여 ISR(Interrupt Service Routine)을 수행**한다.

<br>

---
# ✅ 9. CPU 스케줄링
- 멀티태스킹 환경에서 CPU가 어떤 프로세스에 **언제** CPU를 줄지 결정하는 알고리즘
## 🔹 주요 알고리즘
| 이름               | 특징                     |
| ---------------- | ---------------------- |
| FCFS             | First Come First Serve |
| SJF              | 짧은 작업 먼저               |
| RR               | 라운드 로빈, 타임 슬라이스        |
| Priority         | 우선순위 기반                |
| Multilevel Queue | 우선순위별 큐 나눔             |
- 👉 스케줄링 알고리즘은 **응답 시간, 대기 시간, 공정성, 처리량**을 기준으로 선택된다.

<br>

---
# ✅ 10. CPU 성능 병목 요인
## 🔹 1) 캐시 미스
- 잘못된 데이터 정렬, 무식한 반복문
## 🔹 2) 문맥 전환 과다
- 과도한 스레드 생성, 잘못된 동기화
## 🔹 3) I/O 블로킹
- CPU는 놀고 있는데 디스크 대기
## 🔹 4) Lock 경쟁
- 병렬 환경에서 락 점유 충돌 발생

<br>

---
# ✅ 11. 개발자 입장에서 CPU 최적화는?
## 🔹 소프트웨어에서 CPU 활용을 최적화하는 법
- **알고리즘 최적화**: 시간복잡도 낮추기
- **자료구조 선택**: 정렬/탐색에 적합한 구조
- **스레드 최소화**: 과도한 병렬처리는 독
- **Loop Unrolling**: 반복문 연산 병렬화
- **Branch Prediction 고려**: 조건문 최소화
- **캐시 친화적 코드 작성**: 배열은 선형 접근하라
- **System Call 최소화**: 커널 모드 진입 줄이기
