# 🧠 프로세스(Process) — "운영체제의 핵심 전투 단위"

---

# ✅ 프로세스란 무엇인가?
- **실행 중인 프로그램(Program in Execution)**
- 운영체제(OS)에서 할당된 자원들과 함께 관리되는 실행 단위
- 프로세스 = 코드(명령어) + 데이터 + 자원(메모리, 파일 등) + 제어 흐름(CPU 상태)

<br>

#### 프로그램 vs 프로세스
<img src="https://github.com/user-attachments/assets/f9be90bd-5844-4ae9-88ee-46a1b853969b" width="700" height="200"/>

---

# 🧱 프로세스의 구조 (메모리 구성)
<img src="https://github.com/user-attachments/assets/65044705-bb36-44da-b9d6-3439b7de8a6f" width="200" height="300"/>

```
┌────────────────────────┐
│      Stack             │ ← 함수 호출, 지역변수, 리턴주소
├────────────────────────┤
│      Heap              │ ← new로 동적할당된 객체들
├────────────────────────┤
│      Data (초기화)     │ ← 전역변수 중 초기화된 것
├────────────────────────┤
│      BSS (미초기화)    │ ← 전역변수 중 초기화 안 된 것
├────────────────────────┤
│      Text (Code)       │ ← 실행할 기계어 명령어들
└────────────────────────┘
```

- Stack: 함수 호출 시마다 쌓이고, 반환 시마다 사라진다.
- Heap: JVM의 GC 대상. 자바에서 new로 할당한 객체가 여기에.
- Text: 실행파일의 명령어. 읽기 전용.

---

# 🧾 프로세스 제어 블록 (PCB, Process Control Block)
- OS는 수많은 프로세스를 추적하고 통제해야 한다. 그 열쇠가 PCB다.
- PCB는 "운영체제 커널 영역 메모리"에 저장된다.
#### PCB의 구성
- PID (Process ID): 프로세스의 고유한 식별자.
- Program Counter (PC): 다음에 실행할 명령어의 주소. (문맥교환 후 필요)
- Register Set: CPU 레지스터 저장. (문맥교환 후 필요)
- Process State: Ready, Running, Waiting 등 상태 정보.
- Scheduling Info: 우선순위, 큐 위치 등. (프로세스 스케줄링에 필요)
- Memory Info: 코드, 스택, 힙 등 주소 정보.
- I/O Info: 연 파일, 포트, 디바이스 등. (자원 회수나, 충돌 피하기에 필요)
#### 의의:
- CPU가 프로세스를 바꿀 때는 PCB를 저장/복원한다. 이걸 **문맥교환(context switch)**라고 부른다.

---

# ⚙️ 프로세스 상태 전이 (5 State Model)
- OS는 프로세스를 아래의 상태들로 나눠서 관리한다:
```
New → Ready → Running → Waiting
 ↑           ↓           ↑
 └────────── Exit ←──────┘
```

<img src="https://github.com/user-attachments/assets/502b66c1-0420-4bfb-905e-e51be0bda376" width="600" height="300"/>

- Running에서 I/O 발생 시 → Waiting.
- I/O 끝나면 → Ready로 복귀.
- 다 실행하면 Exit로 종료.

---

# 🧩 문맥교환 (Context Switching)
#### 정의:
- CPU가 다른 프로세스로 전환할 때 현재 프로세스의 상태(레지스터, PC 등)를 저장하고, 새로운 프로세스의 상태를 불러오는 작업.
#### 비용:
- 매우 비쌈. 캐시 무효화, 메모리 접근 변경, 시간 소모.
- 그래서 빠른 전환을 위해 최소화가 중요. (이유: 문맥교환은 생산적인 일이 아니다.)
#### 예시: 스레드 간 전환 < 프로세스 간 전환
- CPU가 스레드끼리 바뀌는 건 가볍고 빠르지만, 프로세스를 바꾸는 건 무겁고 느리다.
- 스레드는 같은 프로세스(같은 JVM) 안에서 실행된다.
  - Heap, 코드, 파일 등 자원을 전부 공유한다.
  - → 메모리 구조, 캐시, 페이지 테이블 전부 그대로 사용 가능.
  - → 레지스터와 Stack만 스왑하면 끝.

---

# 🔧 프로세스 생성과 종료
#### 생성
- 시스템 콜: fork(), exec(), CreateProcess()
- 부모 프로세스 → 자식 프로세스 생성
#### 종료
- 명시적 종료: exit() 호출
- 예외 상황: divide by 0, segmentation fault
- 자식 프로세스 종료 시 부모가 처리 안 하면 좀비 프로세스(zombie) 발생

---

# 📌 프로세스 vs 스레드
<img src="https://github.com/user-attachments/assets/0a78bb95-4efd-4f89-b8f0-9defa59f19bd" width="700" height="250"/>

- 프로세스는 격리된 자식.
- 스레드는 같은 몸체의 팔, 다리.


