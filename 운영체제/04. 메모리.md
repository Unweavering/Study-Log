# ✅ 메모리
- CPU가 직접 접근 가능한 **휘발성 저장장치**
- CPU는 그저 **메모리**에 올라와 있는 프로그램의 명령어들을 실행할 뿐이다
- 커널 영역과, 유저 영역이 있고, 유저영역에 프로세스마다 코드/데이터/힙/스택 가상 메모리를 부여한다.
- MMU와 페이지테이블로 가상 메모리를 물리 메모리와 매핑한다


<br>

---
# 메모리 구조 (프로세스 관점)
<img width="257" height="411" alt="image" src="https://github.com/user-attachments/assets/d319521b-0a7a-4af0-bc77-b273842d3287" />



| 영역            | 설명               | 예시                  |
| ------------- | ---------------- | ------------------- |
| **코드(Code)**  | 실행할 명령어          | 컴파일된 기계어            |
| **데이터(Data)** | 전역 변수, static 변수 | `static int a = 5;` |
| **힙(Heap)**   | 동적 할당            | `new`, `malloc`     |
| **스택(Stack)** | 함수 호출, 지역 변수     | 지역변수, 함수 호출 스택프레임   |
- C언어의 메모리 구조이다.
- ❗ 주의
  - 힙은 개발자가 할당 & 해제 책임 (GC 언어라면 GC가 정리)
  - 스택은 함수 호출시 자동으로 쌓이고 해제됨
## Java
- Java는 JVM이 추상화한 메모리 구조를 사용한다
<img width="700" height="365" alt="image" src="https://github.com/user-attachments/assets/054e1dc8-a959-4889-9e8a-aa1dc92c5aa8" />

| 구역                         | 설명                                    |
| -------------------------- | ------------------------------------- |
| 🔹 **Method Area**         | 클래스 구조 정보, static 변수, 메서드 바이트코드 저장됨   |
| 🔹 **Heap**                | 모든 객체 저장. GC(Garbage Collector) 관리 대상 |
| 🔹 **Stack**               | 스레드별로 존재. 메서드 호출 시 프레임이 쌓이고, 반환 시 제거됨 |
| 🔹 **PC Register**         | 현재 실행 중인 바이트코드 명령어 주소 저장              |
| 🔹 **Native Method Stack** | Java 외 네이티브 코드 (C 등) 실행 시 사용하는 공간     |


<br>

---
# 메모리의 계층 구조 (속도 vs 용량)
<img width="481" height="258" alt="image" src="https://github.com/user-attachments/assets/13ad339a-dc7d-45f8-ba96-39c5c9c90c02" />

| 계층           | 속도         | 크기    | 설명                |
| ------------ | ---------- | ----- | ----------------- |
| 레지스터         | 🟥 최고속도    | 매우 작음 | CPU 내부            |
| L1/L2/L3 캐시  | 🟥 빠름      | 작음    | CPU와 RAM 사이의 버퍼   |
| 메인 메모리(RAM)  | 🟨 보통      | 중간    | 우리가 보통 말하는 메모리    |
| 디스크(HDD/SSD) | 🟦 느림      | 큼     | 영구 저장소            |
| 네트워크         | 🚫 끔찍하게 느림 | 상상초월  | 외부 요청 (API, DB 등) |
- 👉 메모리는 디스크보다 수십만 배 빠르다.
- 👉 캐시는 메모리보다도 수십 배 빠르다.
- 👉 왜 캐시가 필요한지도 이 계층 구조 때문에 생겨난 거다.
## 캐시란?
- **CPU ↔ RAM 간 속도 차이를 극복하기 위한 고속 임시 저장소.**
- 자주 접근하는 데이터를 가까운 곳에 두어 처리 속도를 높인다.
### 지역성의 원리 (Principle of Locality)
- 캐시 성능의 핵심. 모든 고성능 시스템은 이 원리에 기반한다.
#### 시간 지역성 (Temporal Locality)
- 최근 접근한 데이터는 곧 또 접근될 확률이 높다.
- 예: 반복문 안에서 사용하는 변수, 함수 호출 직후 동일한 코드 실행 등
#### 공간 지역성 (Spatial Locality)
- 근처에 있는 데이터도 함께 접근될 확률이 높다.
- 예: 배열 탐색, 메모리 순차 접근, 함수 내부의 지역 변수 등
