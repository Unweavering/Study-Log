# ✅ 메모리
- CPU가 I/O장치를 거치지 않고 접근할 수 있는 **휘발성 저장장치** (by 메모리 컨트롤러, 시스템 버스)
- CPU는 그저 **메모리**에 올라와 있는 프로그램의 명령어들을 실행할 뿐이다
- 커널 영역과, 유저 영역이 있고, 유저영역에 프로세스마다 코드/데이터/힙/스택 가상 메모리를 부여한다.
- MMU와 페이지테이블로 가상 메모리를 물리 메모리와 매핑한다


<br>

---
# ✅ 메모리 구조 (프로세스 관점)
<img width="257" height="411" alt="image" src="https://github.com/user-attachments/assets/d319521b-0a7a-4af0-bc77-b273842d3287" />



| 영역            | 설명               | 예시                  |
| ------------- | ---------------- | ------------------- |
| **코드(Code)**  | 실행할 명령어          | 컴파일된 기계어            |
| **데이터(Data)** | 전역 변수, static 변수 | `static int a = 5;` |
| **힙(Heap)**   | 동적 할당            | `new`, `malloc`     |
| **스택(Stack)** | 함수 호출, 지역 변수     | 지역변수, 함수 호출 스택프레임   |
- UNIX, C언어의 메모리 구조이다.
- ❗ 주의
  - 힙은 개발자가 할당 & 해제 책임 (GC 언어라면 GC가 정리)
  - 스택은 함수 호출시 자동으로 쌓이고 해제됨
  - BSS : 데이터영역밑에 초기화 안된 전역, static 변수. 파일크기를 작게하기위해 초기화안함. 프로그램 실행시 OS가 0으로 초기화 해줌
## Java
<img width="700" height="365" alt="image" src="https://github.com/user-attachments/assets/054e1dc8-a959-4889-9e8a-aa1dc92c5aa8" />

| 구역                         | 설명                                    |
| -------------------------- | ------------------------------------- |
| 🔹 **Method Area**         | 클래스 구조 정보, static 변수, 메서드 바이트코드 저장됨   |
| 🔹 **Heap**                | 모든 객체 저장. GC(Garbage Collector) 관리 대상 |
| 🔹 **Stack**               | 스레드별로 존재. 메서드 호출 시 프레임이 쌓이고, 반환 시 제거됨 |
| 🔹 **PC Register**         | 현재 실행 중인 바이트코드 명령어 주소 저장              |
| 🔹 **Native Method Stack** | Java 외 네이티브 코드 (C 등) 실행 시 사용하는 공간     |
- Java는 JVM이 추상화한 메모리 구조를 사용한다
- OS가 JVM에 코드/데이터/힙/스택 메모리를 부여하고, JVM가 그위에 추상 메모리를 만들어 Java 프로그램을 실행한다.
- 각 자바 프로그램은 실행 시 독립된 JVM 인스턴스(=OS 프로세스)에서 구동된다. (JVM 인스턴스 자체가 OS관점에서 하나의 프로세스이다.)

<br>

---
# ✅ 메모리의 계층 구조 (속도 vs 용량)
<img width="481" height="258" alt="image" src="https://github.com/user-attachments/assets/13ad339a-dc7d-45f8-ba96-39c5c9c90c02" />

| 계층           | 속도         | 크기    | 설명                |
| ------------ | ---------- | ----- | ----------------- |
| 레지스터         | 🟥 최고속도    | 매우 작음 | CPU 내부            |
| L1/L2/L3 캐시  | 🟥 빠름      | 작음    | CPU와 RAM 사이의 버퍼   |
| 메인 메모리(RAM)  | 🟨 보통      | 중간    | 우리가 보통 말하는 메모리    |
| 디스크(HDD/SSD) | 🟦 느림      | 큼     | 영구 저장소            |
| 네트워크         | 🚫 끔찍하게 느림 | 상상초월  | 외부 요청 (API, DB 등) |
- 👉 메모리는 디스크보다 수십만 배 빠르다.
- 👉 캐시는 메모리보다도 수십 배 빠르다.
- 👉 왜 캐시가 필요한지도 이 계층 구조 때문에 생겨난 거다.
## 캐시
- **CPU ↔ RAM 간 속도 차이를 극복하기 위한 고속 임시 저장소.**
- 자주 접근하는 데이터를 가까운 곳에 두어 처리 속도를 높인다.
### 지역성의 원리 (Principle of Locality)
- 캐시 성능의 핵심
#### 시간 지역성 (Temporal Locality)
- 최근 접근한 데이터는 곧 또 접근될 확률이 높다.
- 예: 반복문 안에서 사용하는 변수, 함수 호출 직후 동일한 코드 실행 등
#### 공간 지역성 (Spatial Locality)
- 근처에 있는 데이터도 함께 접근될 확률이 높다.
- 예: 배열 탐색, 메모리 순차 접근, 함수 내부의 지역 변수 등
## 캐시 히트 vs 캐시 미스
<img width="521" height="234" alt="image" src="https://github.com/user-attachments/assets/dcc5fb97-3963-4b01-b4fd-95a8f41222b7" />

| 용어    | 설명                    | 영향        |
| ----- | --------------------- | --------- |
| 캐시 히트 | 요청한 데이터가 캐시에 존재       | 빠른 접근     |
| 캐시 미스 | 캐시에 없어 RAM이나 디스크까지 탐색 | 느림, 성능 저하 |
### 캐시 매핑 방식 (어떻게 데이터를 캐시에 배치할까?)
| 방식                         | 설명                          | 특징            |
| -------------------------- | --------------------------- | ------------- |
| 직접 매핑 (Direct Mapping)     | 특정 주소 → 특정 캐시 슬롯에만 저장       | 충돌 심하지만 구현 간단 |
| 연관 매핑 (Fully Associative)  | 어느 슬롯에도 저장 가능               | 충돌 없음, 검색 느림  |
| 집합 연관 매핑 (Set-Associative) | 캐시를 여러 집합으로 나눠, 그 안에서 연관 매핑 | 실전 최다 사용      |
### 웹 브라우저의 캐시
| 기술      | 저장 위치    | 만료 여부  | 설명                  |
| ------- | -------- | ------ | ------------------- |
| 쿠키      | 서버/클라이언트 | 서버 설정  | 요청마다 자동 전송, 로그인 유지  |
| 로컬 스토리지 | 클라이언트    | 무제한    | JS로 접근, 영구 저장 가능    |
| 세션 스토리지 | 클라이언트    | 탭 종료 시 | 탭당 격리, 민감 정보 저장에 유리 |
### 데이터베이스의 캐싱 계층
<img width="467" height="251" alt="image" src="https://github.com/user-attachments/assets/3409314c-45fc-4cce-9141-4c991ce696c0" />

- 쿼리 캐시: 자주 쓰는 SQL 결과 저장 (ex. Redis 캐시)
- 인덱스 캐시: 인덱스 데이터를 메모리에 올림
- 버퍼 풀: 디스크의 데이터를 RAM으로 읽어온 공간 (MySQL InnoDB 등)

<br>

---
# ✅ 메모리 관리
## 가상 메모리 (Virtual Memory)
<img width="528" height="332" alt="image" src="https://github.com/user-attachments/assets/32c9f9f6-8637-4d24-b9a5-8a9feaa34c0d" />

- 물리 메모리보다 더 큰 주소 공간 제공, 각 프로세스의 메모리 분리, 보안성 향상.
### 스와핑(Swapping)
- 메모리가 부족하면 디스크로 페이지를 밀어냄
- 비활성 데이터를 스왑 공간으로 이동
### 페이지 폴트(Page Fault)
- 프로그램이 접근한 페이지가 메모리에 없을 때 발생
- OS가 디스크에서 페이지 불러옴 → 속도 저하의 핵심 원인
## 스레싱 (Thrashing)
<img width="346" height="186" alt="image" src="https://github.com/user-attachments/assets/1ee49103-a074-4029-91f7-daeb79cce562" />

- 정의:
  - 페이지 폴트가 너무 잦아 OS가 계속 스와핑만 하고 실질적인 작업은 못하는 상태
  - CPU사용률이 낮아지고, OS가 CPU사용률 높이려고 프로세스를 더 실행하는 악순환
- 원인:
  - 작업 세트가 메모리보다 큼
  - 너무 많은 프로세스를 동시에 메모리에 올림
- 해결:
  - 하드웨어적 대응
    - RAM 용량 늘림
    - HDD → SSD로 교체 (I/O 속도 향상)
  - 소프트웨어적 대응
    - 작업 세트 모델 (Working Set Model):
      - → 현재 사용 중인 페이지 집합만 메모리에 유지
    - PFF(Page Fault Frequency):
      - → 페이지 폴트 발생률이 기준 이상이면 프로세스 중지/스왑
      - → 기준 이하이면 메모리 추가 할당

### 작업 세트(Working Set)
- 현시점에 프로세스가 원활히 수행되기 위해 메모리에 한꺼번에 올라와있어야 되는 페이지 집합 (지역성의 원리)
- 운영체제가 최근 일정 시간(t) 동안 프로세스가 접근한 페이지들을 추적 
- 이걸 미리 메모리에 올려놔서 스와핑과 탐색 시간을 줄인다
### PFF
- 페이지 폴트가 발생하는 빈도를 기반으로, 메모리 할당량을 동적으로 조절하는 기법

| 상황                   | 조치                       |
| -------------------- | ------------------------ |
| PFF ↑ (페이지 폴트 자주 발생) | → **메모리 부족** → 메모리 추가 할당 |
| PFF ↓ (페이지 폴트 거의 없음) | → **메모리 낭비** → 일부 페이지 스왑 |

## 메모리 할당
### 연속 할당
#### 고정 분할 방식
#### 가변 분할 방식
### 불연속 할당
#### 페이징
#### 세그멘테이션
#### 페이지드 세그멘테이션
## 페이지 교체 알고리즘
### 오프라인 알고리즘
### FIFO
### LRU
#### NUR
### LFU
