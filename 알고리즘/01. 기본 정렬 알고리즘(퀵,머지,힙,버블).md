# 📊 분류 기준
![image](https://github.com/user-attachments/assets/85ecbb4a-60f3-4c6a-98aa-b17f967aeb62)
![image](https://github.com/user-attachments/assets/cf094e0f-9819-43bd-b028-485e1200d2d9)

## 🔥 1. 시간복잡도 (Time Complexity)
- O(n²): 입력 크기 커지면 지옥행.
- O(n log n): 실무에선 이걸 써야 산다.
- 근데 왜 O(n²) 정렬 공부?
  - 고급 알고리즘 구현 원리의 밑바탕이 될 수 있음
  - 비효율을 이해하는 자만이 효율을 설계할 수 있다.
## 🔥 2. 공간복잡도 (Space Complexity)
- In-place: 추가 메모리 거의 안 씀. 
- Not In-place: 추가 메모리 씀.
## 🔥 3. 안정성 (Stability)
- Stable: 값이 같을 때 원래 순서 유지. 
- Unstable: 순서 박살남. 
> 예: `[(3, A), (3, B)]` → 정렬 후 `(3, A)`가 앞에 있어야 **Stable**.
## 🔥 4. 방식 (Method)
- 비교 정렬 (Comparison Sort): 두 원소 비교. 
- 분포 정렬 (Distribution Sort): 비교 안 하고 값 자체로 분류. 예: 계수 정렬(Counting Sort), 기수 정렬(Radix Sort).

<br>

---
# 🔧 버블 정렬 (Bubble Sort)
## ✅ 개념
- 인접한 두 원소를 비교하여, 큰 값을 뒤로 보낸다.
- 거품이 수면 위로 떠오르 듯이, 가장 큰 수가 "거품처럼" 뒤로 떠오르는 방식.
## 📌 구현 로직
```
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
        }
    }
}
```
## ⏱️ 시간복잡도
- 최악, 평균: O(n²)
- 최선 (이미 정렬된 경우): O(n) (개선된 버블 정렬에서)
## 🧠 특징
- In-place, Stable
- 학습용으로 적절하나 실전에는 부적절
- 최적화 없이 사용 시 성능 최악

<br>

---
# 🔧 선택 정렬 (Selection Sort)
## ✅ 개념
- 남은 리스트에서 최솟값을 선택하여 앞쪽에 배치.
## 📌 구현 로직
```
for (int i = 0; i < arr.length - 1; i++) {
    int minIdx = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIdx]) {
            minIdx = j;
        }
    }
    swap(arr, i, minIdx);
}
```
## ⏱️ 시간복잡도
- 항상 O(n²)
## 🧠 특징
- In-place, Unstable
- 비교 횟수는 고정되어 있음
- 실무에서는 거의 사용되지 않음

<br>

---
# 🔧 삽입 정렬 (Insertion Sort)
## ✅ 개념
- 정렬된 부분 배열에 원소를 '삽입'하는 방식
- 카드 정렬하는 방식과 유사
## 📌 구현 로직
```
for (int i = 1; i < arr.length; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```
## ⏱️ 시간복잡도
- 최악, 평균: O(n²)
- 최선: O(n)
## 🧠 특징
- In-place, Stable
- 데이터가 거의 정렬된 상태일 경우 매우 효율적
- 삽입에 적합한 경우: 동적 리스트, 실시간 정렬

<br>

---
# ⚡ 병합 정렬 (Merge Sort)
## ✅ 개념
- 리스트를 반으로 쪼개서 정렬한 후 병합
- 분할 정복(Divide and Conquer) 패턴
## 📌 구현 로직 (Java)
```
void mergeSort(int[] arr, int left, int right) {
    if (left >= right) return;
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```
## ⏱️ 시간복잡도
- 항상 O(n log n)
## 🧠 특징
- Not In-place (보조 배열 필요), Stable
- 대용량 정렬 시 강력 (외부 정렬에도 활용)
- 병렬화에 적합
