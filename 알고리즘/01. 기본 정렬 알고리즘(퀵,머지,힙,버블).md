# 📊 분류 기준
![image](https://github.com/user-attachments/assets/85ecbb4a-60f3-4c6a-98aa-b17f967aeb62)
![image](https://github.com/user-attachments/assets/cf094e0f-9819-43bd-b028-485e1200d2d9)

## 🔥 1. 시간복잡도 (Time Complexity)
- O(n²): 입력 크기 커지면 지옥행.
- O(n log n): 실무에선 이걸 써야 산다.
## 🔥 2. 공간복잡도 (Space Complexity)
- In-place: 추가 메모리 거의 안 씀. 
- Not In-place: 추가 메모리 씀.
## 🔥 3. 안정성 (Stability)
- Stable: 값이 같을 때 원래 순서 유지. 
- Unstable: 순서 박살남. 
> 예: `[(3, A), (3, B)]` → 정렬 후 `(3, A)`가 앞에 있어야 **Stable**.
## 🔥 4. 방식 (Method)
- 비교 정렬 (Comparison Sort): 두 원소 비교. 
- 분포 정렬 (Distribution Sort): 비교 안 하고 값 자체로 분류. 예: 계수 정렬(Counting Sort), 기수 정렬(Radix Sort).

<br>

---
# 🔧 버블 정렬 (Bubble Sort)
## ✅ 개념
- 인접한 두 원소를 비교하여, 큰 값을 뒤로 보낸다.
- 거품이 수면 위로 떠오르 듯이, 가장 큰 수가 "거품처럼" 뒤로 떠오르는 방식.
## 📌 구현 로직
```
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
        }
    }
}
```
## ⏱️ 시간복잡도
- 최악, 평균: O(n²)
- 최선 (이미 정렬된 경우): O(n) (개선된 버블 정렬에서)
## 🧠 특징
- In-place, Stable
- 학습용으로 적절하나 실전에는 부적절
- 최적화 없이 사용 시 성능 최악

<br>

---
